package claudecode

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/safedep/gryph/agent"
)

// HookTypes are the hook types supported by Claude Code.
var HookTypes = []string{
	"PreToolUse",
	"PostToolUse",
	"Notification",
}

// GenerateHookScript generates the shell script content for a hook.
func GenerateHookScript(hookType string) string {
	return fmt.Sprintf(`#!/bin/bash
# Gryph hook for Claude Code - %s
# Auto-generated by gryph install

# Read JSON from stdin and pipe to gryph
cat | gryph _hook claude-code %s
`, hookType, hookType)
}

// InstallHooks installs hooks for Claude Code.
func InstallHooks(ctx context.Context, opts agent.InstallOptions) (*agent.InstallResult, error) {
	result := &agent.InstallResult{
		BackupPaths: make(map[string]string),
	}

	detection, err := Detect(ctx)
	if err != nil {
		result.Error = err
		return result, err
	}

	if !detection.Installed {
		result.Error = fmt.Errorf("Claude Code is not installed")
		return result, result.Error
	}

	hooksDir := detection.HooksPath

	// Create hooks directory if it doesn't exist
	if !opts.DryRun {
		if err := os.MkdirAll(hooksDir, 0700); err != nil {
			result.Error = fmt.Errorf("failed to create hooks directory: %w", err)
			return result, result.Error
		}
	}

	for _, hookType := range HookTypes {
		hookPath := filepath.Join(hooksDir, hookType+".sh")

		// Check if hook already exists
		if _, err := os.Stat(hookPath); err == nil {
			if opts.Backup && !opts.DryRun {
				backupPath := fmt.Sprintf("%s.backup.%s", hookPath, time.Now().Format("20060102150405"))
				if err := os.Rename(hookPath, backupPath); err != nil {
					result.Warnings = append(result.Warnings, fmt.Sprintf("failed to backup %s: %v", hookType, err))
				} else {
					result.BackupPaths[hookType] = backupPath
				}
			} else if !opts.Force && !opts.DryRun {
				result.Warnings = append(result.Warnings, fmt.Sprintf("%s hook already exists, skipping (use --force to overwrite)", hookType))
				continue
			}
		}

		if opts.DryRun {
			result.HooksInstalled = append(result.HooksInstalled, hookType)
			continue
		}

		// Write hook script
		script := GenerateHookScript(hookType)
		if err := os.WriteFile(hookPath, []byte(script), 0700); err != nil {
			result.Error = fmt.Errorf("failed to write %s hook: %w", hookType, err)
			return result, result.Error
		}

		result.HooksInstalled = append(result.HooksInstalled, hookType)
	}

	result.Success = true
	return result, nil
}

// UninstallHooks removes hooks from Claude Code.
func UninstallHooks(ctx context.Context, opts agent.UninstallOptions) (*agent.UninstallResult, error) {
	result := &agent.UninstallResult{}

	detection, err := Detect(ctx)
	if err != nil {
		result.Error = err
		return result, err
	}

	if !detection.Installed {
		result.Success = true
		return result, nil
	}

	hooksDir := detection.HooksPath

	for _, hookType := range HookTypes {
		hookPath := filepath.Join(hooksDir, hookType+".sh")

		if _, err := os.Stat(hookPath); os.IsNotExist(err) {
			continue
		}

		if opts.DryRun {
			result.HooksRemoved = append(result.HooksRemoved, hookType)
			continue
		}

		// Check if we should restore backup
		if opts.RestoreBackup && opts.BackupDir != "" {
			// Look for backup files
			pattern := filepath.Join(opts.BackupDir, "claude-code", hookType+".sh.backup.*")
			matches, _ := filepath.Glob(pattern)
			if len(matches) > 0 {
				// Use most recent backup
				backupPath := matches[len(matches)-1]
				if err := os.Rename(backupPath, hookPath); err == nil {
					result.BackupsRestored = true
					result.HooksRemoved = append(result.HooksRemoved, hookType)
					continue
				}
			}
		}

		if err := os.Remove(hookPath); err != nil {
			result.Error = fmt.Errorf("failed to remove %s hook: %w", hookType, err)
			return result, result.Error
		}

		result.HooksRemoved = append(result.HooksRemoved, hookType)
	}

	result.Success = true
	return result, nil
}

// GetHookStatus checks the current hook state.
func GetHookStatus(ctx context.Context) (*agent.HookStatus, error) {
	status := &agent.HookStatus{}

	detection, err := Detect(ctx)
	if err != nil {
		return status, err
	}

	if !detection.Installed {
		return status, nil
	}

	hooksDir := detection.HooksPath
	status.Valid = true

	for _, hookType := range HookTypes {
		hookPath := filepath.Join(hooksDir, hookType+".sh")

		if _, err := os.Stat(hookPath); os.IsNotExist(err) {
			continue
		}

		status.Installed = true
		status.Hooks = append(status.Hooks, hookType)

		// Verify hook is executable
		info, err := os.Stat(hookPath)
		if err != nil {
			status.Valid = false
			status.Issues = append(status.Issues, fmt.Sprintf("%s: cannot read file", hookType))
			continue
		}

		if info.Mode()&0100 == 0 {
			status.Valid = false
			status.Issues = append(status.Issues, fmt.Sprintf("%s: not executable", hookType))
		}
	}

	return status, nil
}
