// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/safedep/gryph/storage/ent/auditevent"
	"github.com/safedep/gryph/storage/ent/predicate"
	"github.com/safedep/gryph/storage/ent/selfaudit"
	"github.com/safedep/gryph/storage/ent/session"
	"github.com/safedep/gryph/storage/ent/streamcheckpoint"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAuditEvent       = "AuditEvent"
	TypeSelfAudit        = "SelfAudit"
	TypeSession          = "Session"
	TypeStreamCheckpoint = "StreamCheckpoint"
)

// AuditEventMutation represents an operation that mutates the AuditEvent nodes in the graph.
type AuditEventMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	sequence             *int
	addsequence          *int
	timestamp            *time.Time
	duration_ms          *int64
	addduration_ms       *int64
	agent_name           *string
	agent_version        *string
	working_directory    *string
	action_type          *auditevent.ActionType
	tool_name            *string
	result_status        *auditevent.ResultStatus
	error_message        *string
	payload              *map[string]interface{}
	diff_content         *string
	raw_event            *map[string]interface{}
	conversation_context *string
	is_sensitive         *bool
	clearedFields        map[string]struct{}
	session              *uuid.UUID
	clearedsession       bool
	done                 bool
	oldValue             func(context.Context) (*AuditEvent, error)
	predicates           []predicate.AuditEvent
}

var _ ent.Mutation = (*AuditEventMutation)(nil)

// auditeventOption allows management of the mutation configuration using functional options.
type auditeventOption func(*AuditEventMutation)

// newAuditEventMutation creates new mutation for the AuditEvent entity.
func newAuditEventMutation(c config, op Op, opts ...auditeventOption) *AuditEventMutation {
	m := &AuditEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditEventID sets the ID field of the mutation.
func withAuditEventID(id uuid.UUID) auditeventOption {
	return func(m *AuditEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditEvent
		)
		m.oldValue = func(ctx context.Context) (*AuditEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditEvent sets the old AuditEvent of the mutation.
func withAuditEvent(node *AuditEvent) auditeventOption {
	return func(m *AuditEventMutation) {
		m.oldValue = func(context.Context) (*AuditEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditEvent entities.
func (m *AuditEventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditEventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditEventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSessionID sets the "session_id" field.
func (m *AuditEventMutation) SetSessionID(u uuid.UUID) {
	m.session = &u
}

// SessionID returns the value of the "session_id" field in the mutation.
func (m *AuditEventMutation) SessionID() (r uuid.UUID, exists bool) {
	v := m.session
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionID returns the old "session_id" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldSessionID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionID: %w", err)
	}
	return oldValue.SessionID, nil
}

// ResetSessionID resets all changes to the "session_id" field.
func (m *AuditEventMutation) ResetSessionID() {
	m.session = nil
}

// SetSequence sets the "sequence" field.
func (m *AuditEventMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *AuditEventMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *AuditEventMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *AuditEventMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *AuditEventMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *AuditEventMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *AuditEventMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *AuditEventMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *AuditEventMutation) SetDurationMs(i int64) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *AuditEventMutation) DurationMs() (r int64, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldDurationMs(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *AuditEventMutation) AddDurationMs(i int64) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *AuditEventMutation) AddedDurationMs() (r int64, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *AuditEventMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[auditevent.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *AuditEventMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *AuditEventMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, auditevent.FieldDurationMs)
}

// SetAgentName sets the "agent_name" field.
func (m *AuditEventMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *AuditEventMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *AuditEventMutation) ResetAgentName() {
	m.agent_name = nil
}

// SetAgentVersion sets the "agent_version" field.
func (m *AuditEventMutation) SetAgentVersion(s string) {
	m.agent_version = &s
}

// AgentVersion returns the value of the "agent_version" field in the mutation.
func (m *AuditEventMutation) AgentVersion() (r string, exists bool) {
	v := m.agent_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentVersion returns the old "agent_version" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldAgentVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentVersion: %w", err)
	}
	return oldValue.AgentVersion, nil
}

// ClearAgentVersion clears the value of the "agent_version" field.
func (m *AuditEventMutation) ClearAgentVersion() {
	m.agent_version = nil
	m.clearedFields[auditevent.FieldAgentVersion] = struct{}{}
}

// AgentVersionCleared returns if the "agent_version" field was cleared in this mutation.
func (m *AuditEventMutation) AgentVersionCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldAgentVersion]
	return ok
}

// ResetAgentVersion resets all changes to the "agent_version" field.
func (m *AuditEventMutation) ResetAgentVersion() {
	m.agent_version = nil
	delete(m.clearedFields, auditevent.FieldAgentVersion)
}

// SetWorkingDirectory sets the "working_directory" field.
func (m *AuditEventMutation) SetWorkingDirectory(s string) {
	m.working_directory = &s
}

// WorkingDirectory returns the value of the "working_directory" field in the mutation.
func (m *AuditEventMutation) WorkingDirectory() (r string, exists bool) {
	v := m.working_directory
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkingDirectory returns the old "working_directory" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldWorkingDirectory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkingDirectory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkingDirectory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkingDirectory: %w", err)
	}
	return oldValue.WorkingDirectory, nil
}

// ClearWorkingDirectory clears the value of the "working_directory" field.
func (m *AuditEventMutation) ClearWorkingDirectory() {
	m.working_directory = nil
	m.clearedFields[auditevent.FieldWorkingDirectory] = struct{}{}
}

// WorkingDirectoryCleared returns if the "working_directory" field was cleared in this mutation.
func (m *AuditEventMutation) WorkingDirectoryCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldWorkingDirectory]
	return ok
}

// ResetWorkingDirectory resets all changes to the "working_directory" field.
func (m *AuditEventMutation) ResetWorkingDirectory() {
	m.working_directory = nil
	delete(m.clearedFields, auditevent.FieldWorkingDirectory)
}

// SetActionType sets the "action_type" field.
func (m *AuditEventMutation) SetActionType(at auditevent.ActionType) {
	m.action_type = &at
}

// ActionType returns the value of the "action_type" field in the mutation.
func (m *AuditEventMutation) ActionType() (r auditevent.ActionType, exists bool) {
	v := m.action_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActionType returns the old "action_type" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldActionType(ctx context.Context) (v auditevent.ActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionType: %w", err)
	}
	return oldValue.ActionType, nil
}

// ResetActionType resets all changes to the "action_type" field.
func (m *AuditEventMutation) ResetActionType() {
	m.action_type = nil
}

// SetToolName sets the "tool_name" field.
func (m *AuditEventMutation) SetToolName(s string) {
	m.tool_name = &s
}

// ToolName returns the value of the "tool_name" field in the mutation.
func (m *AuditEventMutation) ToolName() (r string, exists bool) {
	v := m.tool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old "tool_name" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ClearToolName clears the value of the "tool_name" field.
func (m *AuditEventMutation) ClearToolName() {
	m.tool_name = nil
	m.clearedFields[auditevent.FieldToolName] = struct{}{}
}

// ToolNameCleared returns if the "tool_name" field was cleared in this mutation.
func (m *AuditEventMutation) ToolNameCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldToolName]
	return ok
}

// ResetToolName resets all changes to the "tool_name" field.
func (m *AuditEventMutation) ResetToolName() {
	m.tool_name = nil
	delete(m.clearedFields, auditevent.FieldToolName)
}

// SetResultStatus sets the "result_status" field.
func (m *AuditEventMutation) SetResultStatus(as auditevent.ResultStatus) {
	m.result_status = &as
}

// ResultStatus returns the value of the "result_status" field in the mutation.
func (m *AuditEventMutation) ResultStatus() (r auditevent.ResultStatus, exists bool) {
	v := m.result_status
	if v == nil {
		return
	}
	return *v, true
}

// OldResultStatus returns the old "result_status" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldResultStatus(ctx context.Context) (v auditevent.ResultStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultStatus: %w", err)
	}
	return oldValue.ResultStatus, nil
}

// ResetResultStatus resets all changes to the "result_status" field.
func (m *AuditEventMutation) ResetResultStatus() {
	m.result_status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AuditEventMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AuditEventMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AuditEventMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[auditevent.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AuditEventMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AuditEventMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, auditevent.FieldErrorMessage)
}

// SetPayload sets the "payload" field.
func (m *AuditEventMutation) SetPayload(value map[string]interface{}) {
	m.payload = &value
}

// Payload returns the value of the "payload" field in the mutation.
func (m *AuditEventMutation) Payload() (r map[string]interface{}, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldPayload(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *AuditEventMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[auditevent.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *AuditEventMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *AuditEventMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, auditevent.FieldPayload)
}

// SetDiffContent sets the "diff_content" field.
func (m *AuditEventMutation) SetDiffContent(s string) {
	m.diff_content = &s
}

// DiffContent returns the value of the "diff_content" field in the mutation.
func (m *AuditEventMutation) DiffContent() (r string, exists bool) {
	v := m.diff_content
	if v == nil {
		return
	}
	return *v, true
}

// OldDiffContent returns the old "diff_content" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldDiffContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiffContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiffContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiffContent: %w", err)
	}
	return oldValue.DiffContent, nil
}

// ClearDiffContent clears the value of the "diff_content" field.
func (m *AuditEventMutation) ClearDiffContent() {
	m.diff_content = nil
	m.clearedFields[auditevent.FieldDiffContent] = struct{}{}
}

// DiffContentCleared returns if the "diff_content" field was cleared in this mutation.
func (m *AuditEventMutation) DiffContentCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldDiffContent]
	return ok
}

// ResetDiffContent resets all changes to the "diff_content" field.
func (m *AuditEventMutation) ResetDiffContent() {
	m.diff_content = nil
	delete(m.clearedFields, auditevent.FieldDiffContent)
}

// SetRawEvent sets the "raw_event" field.
func (m *AuditEventMutation) SetRawEvent(value map[string]interface{}) {
	m.raw_event = &value
}

// RawEvent returns the value of the "raw_event" field in the mutation.
func (m *AuditEventMutation) RawEvent() (r map[string]interface{}, exists bool) {
	v := m.raw_event
	if v == nil {
		return
	}
	return *v, true
}

// OldRawEvent returns the old "raw_event" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldRawEvent(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawEvent: %w", err)
	}
	return oldValue.RawEvent, nil
}

// ClearRawEvent clears the value of the "raw_event" field.
func (m *AuditEventMutation) ClearRawEvent() {
	m.raw_event = nil
	m.clearedFields[auditevent.FieldRawEvent] = struct{}{}
}

// RawEventCleared returns if the "raw_event" field was cleared in this mutation.
func (m *AuditEventMutation) RawEventCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldRawEvent]
	return ok
}

// ResetRawEvent resets all changes to the "raw_event" field.
func (m *AuditEventMutation) ResetRawEvent() {
	m.raw_event = nil
	delete(m.clearedFields, auditevent.FieldRawEvent)
}

// SetConversationContext sets the "conversation_context" field.
func (m *AuditEventMutation) SetConversationContext(s string) {
	m.conversation_context = &s
}

// ConversationContext returns the value of the "conversation_context" field in the mutation.
func (m *AuditEventMutation) ConversationContext() (r string, exists bool) {
	v := m.conversation_context
	if v == nil {
		return
	}
	return *v, true
}

// OldConversationContext returns the old "conversation_context" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldConversationContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConversationContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConversationContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConversationContext: %w", err)
	}
	return oldValue.ConversationContext, nil
}

// ClearConversationContext clears the value of the "conversation_context" field.
func (m *AuditEventMutation) ClearConversationContext() {
	m.conversation_context = nil
	m.clearedFields[auditevent.FieldConversationContext] = struct{}{}
}

// ConversationContextCleared returns if the "conversation_context" field was cleared in this mutation.
func (m *AuditEventMutation) ConversationContextCleared() bool {
	_, ok := m.clearedFields[auditevent.FieldConversationContext]
	return ok
}

// ResetConversationContext resets all changes to the "conversation_context" field.
func (m *AuditEventMutation) ResetConversationContext() {
	m.conversation_context = nil
	delete(m.clearedFields, auditevent.FieldConversationContext)
}

// SetIsSensitive sets the "is_sensitive" field.
func (m *AuditEventMutation) SetIsSensitive(b bool) {
	m.is_sensitive = &b
}

// IsSensitive returns the value of the "is_sensitive" field in the mutation.
func (m *AuditEventMutation) IsSensitive() (r bool, exists bool) {
	v := m.is_sensitive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSensitive returns the old "is_sensitive" field's value of the AuditEvent entity.
// If the AuditEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditEventMutation) OldIsSensitive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSensitive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSensitive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSensitive: %w", err)
	}
	return oldValue.IsSensitive, nil
}

// ResetIsSensitive resets all changes to the "is_sensitive" field.
func (m *AuditEventMutation) ResetIsSensitive() {
	m.is_sensitive = nil
}

// ClearSession clears the "session" edge to the Session entity.
func (m *AuditEventMutation) ClearSession() {
	m.clearedsession = true
	m.clearedFields[auditevent.FieldSessionID] = struct{}{}
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *AuditEventMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *AuditEventMutation) SessionIDs() (ids []uuid.UUID) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *AuditEventMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the AuditEventMutation builder.
func (m *AuditEventMutation) Where(ps ...predicate.AuditEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditEvent).
func (m *AuditEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditEventMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.session != nil {
		fields = append(fields, auditevent.FieldSessionID)
	}
	if m.sequence != nil {
		fields = append(fields, auditevent.FieldSequence)
	}
	if m.timestamp != nil {
		fields = append(fields, auditevent.FieldTimestamp)
	}
	if m.duration_ms != nil {
		fields = append(fields, auditevent.FieldDurationMs)
	}
	if m.agent_name != nil {
		fields = append(fields, auditevent.FieldAgentName)
	}
	if m.agent_version != nil {
		fields = append(fields, auditevent.FieldAgentVersion)
	}
	if m.working_directory != nil {
		fields = append(fields, auditevent.FieldWorkingDirectory)
	}
	if m.action_type != nil {
		fields = append(fields, auditevent.FieldActionType)
	}
	if m.tool_name != nil {
		fields = append(fields, auditevent.FieldToolName)
	}
	if m.result_status != nil {
		fields = append(fields, auditevent.FieldResultStatus)
	}
	if m.error_message != nil {
		fields = append(fields, auditevent.FieldErrorMessage)
	}
	if m.payload != nil {
		fields = append(fields, auditevent.FieldPayload)
	}
	if m.diff_content != nil {
		fields = append(fields, auditevent.FieldDiffContent)
	}
	if m.raw_event != nil {
		fields = append(fields, auditevent.FieldRawEvent)
	}
	if m.conversation_context != nil {
		fields = append(fields, auditevent.FieldConversationContext)
	}
	if m.is_sensitive != nil {
		fields = append(fields, auditevent.FieldIsSensitive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditevent.FieldSessionID:
		return m.SessionID()
	case auditevent.FieldSequence:
		return m.Sequence()
	case auditevent.FieldTimestamp:
		return m.Timestamp()
	case auditevent.FieldDurationMs:
		return m.DurationMs()
	case auditevent.FieldAgentName:
		return m.AgentName()
	case auditevent.FieldAgentVersion:
		return m.AgentVersion()
	case auditevent.FieldWorkingDirectory:
		return m.WorkingDirectory()
	case auditevent.FieldActionType:
		return m.ActionType()
	case auditevent.FieldToolName:
		return m.ToolName()
	case auditevent.FieldResultStatus:
		return m.ResultStatus()
	case auditevent.FieldErrorMessage:
		return m.ErrorMessage()
	case auditevent.FieldPayload:
		return m.Payload()
	case auditevent.FieldDiffContent:
		return m.DiffContent()
	case auditevent.FieldRawEvent:
		return m.RawEvent()
	case auditevent.FieldConversationContext:
		return m.ConversationContext()
	case auditevent.FieldIsSensitive:
		return m.IsSensitive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditevent.FieldSessionID:
		return m.OldSessionID(ctx)
	case auditevent.FieldSequence:
		return m.OldSequence(ctx)
	case auditevent.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case auditevent.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case auditevent.FieldAgentName:
		return m.OldAgentName(ctx)
	case auditevent.FieldAgentVersion:
		return m.OldAgentVersion(ctx)
	case auditevent.FieldWorkingDirectory:
		return m.OldWorkingDirectory(ctx)
	case auditevent.FieldActionType:
		return m.OldActionType(ctx)
	case auditevent.FieldToolName:
		return m.OldToolName(ctx)
	case auditevent.FieldResultStatus:
		return m.OldResultStatus(ctx)
	case auditevent.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case auditevent.FieldPayload:
		return m.OldPayload(ctx)
	case auditevent.FieldDiffContent:
		return m.OldDiffContent(ctx)
	case auditevent.FieldRawEvent:
		return m.OldRawEvent(ctx)
	case auditevent.FieldConversationContext:
		return m.OldConversationContext(ctx)
	case auditevent.FieldIsSensitive:
		return m.OldIsSensitive(ctx)
	}
	return nil, fmt.Errorf("unknown AuditEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditevent.FieldSessionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionID(v)
		return nil
	case auditevent.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case auditevent.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case auditevent.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case auditevent.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case auditevent.FieldAgentVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentVersion(v)
		return nil
	case auditevent.FieldWorkingDirectory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkingDirectory(v)
		return nil
	case auditevent.FieldActionType:
		v, ok := value.(auditevent.ActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionType(v)
		return nil
	case auditevent.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case auditevent.FieldResultStatus:
		v, ok := value.(auditevent.ResultStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultStatus(v)
		return nil
	case auditevent.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case auditevent.FieldPayload:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case auditevent.FieldDiffContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiffContent(v)
		return nil
	case auditevent.FieldRawEvent:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawEvent(v)
		return nil
	case auditevent.FieldConversationContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConversationContext(v)
		return nil
	case auditevent.FieldIsSensitive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSensitive(v)
		return nil
	}
	return fmt.Errorf("unknown AuditEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditEventMutation) AddedFields() []string {
	var fields []string
	if m.addsequence != nil {
		fields = append(fields, auditevent.FieldSequence)
	}
	if m.addduration_ms != nil {
		fields = append(fields, auditevent.FieldDurationMs)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditEventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case auditevent.FieldSequence:
		return m.AddedSequence()
	case auditevent.FieldDurationMs:
		return m.AddedDurationMs()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case auditevent.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case auditevent.FieldDurationMs:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	}
	return fmt.Errorf("unknown AuditEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditevent.FieldDurationMs) {
		fields = append(fields, auditevent.FieldDurationMs)
	}
	if m.FieldCleared(auditevent.FieldAgentVersion) {
		fields = append(fields, auditevent.FieldAgentVersion)
	}
	if m.FieldCleared(auditevent.FieldWorkingDirectory) {
		fields = append(fields, auditevent.FieldWorkingDirectory)
	}
	if m.FieldCleared(auditevent.FieldToolName) {
		fields = append(fields, auditevent.FieldToolName)
	}
	if m.FieldCleared(auditevent.FieldErrorMessage) {
		fields = append(fields, auditevent.FieldErrorMessage)
	}
	if m.FieldCleared(auditevent.FieldPayload) {
		fields = append(fields, auditevent.FieldPayload)
	}
	if m.FieldCleared(auditevent.FieldDiffContent) {
		fields = append(fields, auditevent.FieldDiffContent)
	}
	if m.FieldCleared(auditevent.FieldRawEvent) {
		fields = append(fields, auditevent.FieldRawEvent)
	}
	if m.FieldCleared(auditevent.FieldConversationContext) {
		fields = append(fields, auditevent.FieldConversationContext)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditEventMutation) ClearField(name string) error {
	switch name {
	case auditevent.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case auditevent.FieldAgentVersion:
		m.ClearAgentVersion()
		return nil
	case auditevent.FieldWorkingDirectory:
		m.ClearWorkingDirectory()
		return nil
	case auditevent.FieldToolName:
		m.ClearToolName()
		return nil
	case auditevent.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case auditevent.FieldPayload:
		m.ClearPayload()
		return nil
	case auditevent.FieldDiffContent:
		m.ClearDiffContent()
		return nil
	case auditevent.FieldRawEvent:
		m.ClearRawEvent()
		return nil
	case auditevent.FieldConversationContext:
		m.ClearConversationContext()
		return nil
	}
	return fmt.Errorf("unknown AuditEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditEventMutation) ResetField(name string) error {
	switch name {
	case auditevent.FieldSessionID:
		m.ResetSessionID()
		return nil
	case auditevent.FieldSequence:
		m.ResetSequence()
		return nil
	case auditevent.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case auditevent.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case auditevent.FieldAgentName:
		m.ResetAgentName()
		return nil
	case auditevent.FieldAgentVersion:
		m.ResetAgentVersion()
		return nil
	case auditevent.FieldWorkingDirectory:
		m.ResetWorkingDirectory()
		return nil
	case auditevent.FieldActionType:
		m.ResetActionType()
		return nil
	case auditevent.FieldToolName:
		m.ResetToolName()
		return nil
	case auditevent.FieldResultStatus:
		m.ResetResultStatus()
		return nil
	case auditevent.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case auditevent.FieldPayload:
		m.ResetPayload()
		return nil
	case auditevent.FieldDiffContent:
		m.ResetDiffContent()
		return nil
	case auditevent.FieldRawEvent:
		m.ResetRawEvent()
		return nil
	case auditevent.FieldConversationContext:
		m.ResetConversationContext()
		return nil
	case auditevent.FieldIsSensitive:
		m.ResetIsSensitive()
		return nil
	}
	return fmt.Errorf("unknown AuditEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, auditevent.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditevent.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, auditevent.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditEventMutation) EdgeCleared(name string) bool {
	switch name {
	case auditevent.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditEventMutation) ClearEdge(name string) error {
	switch name {
	case auditevent.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown AuditEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditEventMutation) ResetEdge(name string) error {
	switch name {
	case auditevent.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown AuditEvent edge %s", name)
}

// SelfAuditMutation represents an operation that mutates the SelfAudit nodes in the graph.
type SelfAuditMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	timestamp     *time.Time
	action        *selfaudit.Action
	agent_name    *string
	details       *map[string]interface{}
	result        *selfaudit.Result
	error_message *string
	tool_version  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SelfAudit, error)
	predicates    []predicate.SelfAudit
}

var _ ent.Mutation = (*SelfAuditMutation)(nil)

// selfauditOption allows management of the mutation configuration using functional options.
type selfauditOption func(*SelfAuditMutation)

// newSelfAuditMutation creates new mutation for the SelfAudit entity.
func newSelfAuditMutation(c config, op Op, opts ...selfauditOption) *SelfAuditMutation {
	m := &SelfAuditMutation{
		config:        c,
		op:            op,
		typ:           TypeSelfAudit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSelfAuditID sets the ID field of the mutation.
func withSelfAuditID(id uuid.UUID) selfauditOption {
	return func(m *SelfAuditMutation) {
		var (
			err   error
			once  sync.Once
			value *SelfAudit
		)
		m.oldValue = func(ctx context.Context) (*SelfAudit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SelfAudit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSelfAudit sets the old SelfAudit of the mutation.
func withSelfAudit(node *SelfAudit) selfauditOption {
	return func(m *SelfAuditMutation) {
		m.oldValue = func(context.Context) (*SelfAudit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SelfAuditMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SelfAuditMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SelfAudit entities.
func (m *SelfAuditMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SelfAuditMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SelfAuditMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SelfAudit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTimestamp sets the "timestamp" field.
func (m *SelfAuditMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SelfAuditMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SelfAuditMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetAction sets the "action" field.
func (m *SelfAuditMutation) SetAction(s selfaudit.Action) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *SelfAuditMutation) Action() (r selfaudit.Action, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldAction(ctx context.Context) (v selfaudit.Action, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *SelfAuditMutation) ResetAction() {
	m.action = nil
}

// SetAgentName sets the "agent_name" field.
func (m *SelfAuditMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *SelfAuditMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ClearAgentName clears the value of the "agent_name" field.
func (m *SelfAuditMutation) ClearAgentName() {
	m.agent_name = nil
	m.clearedFields[selfaudit.FieldAgentName] = struct{}{}
}

// AgentNameCleared returns if the "agent_name" field was cleared in this mutation.
func (m *SelfAuditMutation) AgentNameCleared() bool {
	_, ok := m.clearedFields[selfaudit.FieldAgentName]
	return ok
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *SelfAuditMutation) ResetAgentName() {
	m.agent_name = nil
	delete(m.clearedFields, selfaudit.FieldAgentName)
}

// SetDetails sets the "details" field.
func (m *SelfAuditMutation) SetDetails(value map[string]interface{}) {
	m.details = &value
}

// Details returns the value of the "details" field in the mutation.
func (m *SelfAuditMutation) Details() (r map[string]interface{}, exists bool) {
	v := m.details
	if v == nil {
		return
	}
	return *v, true
}

// OldDetails returns the old "details" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldDetails(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetails: %w", err)
	}
	return oldValue.Details, nil
}

// ClearDetails clears the value of the "details" field.
func (m *SelfAuditMutation) ClearDetails() {
	m.details = nil
	m.clearedFields[selfaudit.FieldDetails] = struct{}{}
}

// DetailsCleared returns if the "details" field was cleared in this mutation.
func (m *SelfAuditMutation) DetailsCleared() bool {
	_, ok := m.clearedFields[selfaudit.FieldDetails]
	return ok
}

// ResetDetails resets all changes to the "details" field.
func (m *SelfAuditMutation) ResetDetails() {
	m.details = nil
	delete(m.clearedFields, selfaudit.FieldDetails)
}

// SetResult sets the "result" field.
func (m *SelfAuditMutation) SetResult(s selfaudit.Result) {
	m.result = &s
}

// Result returns the value of the "result" field in the mutation.
func (m *SelfAuditMutation) Result() (r selfaudit.Result, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldResult(ctx context.Context) (v selfaudit.Result, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ResetResult resets all changes to the "result" field.
func (m *SelfAuditMutation) ResetResult() {
	m.result = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *SelfAuditMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *SelfAuditMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *SelfAuditMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[selfaudit.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *SelfAuditMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[selfaudit.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *SelfAuditMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, selfaudit.FieldErrorMessage)
}

// SetToolVersion sets the "tool_version" field.
func (m *SelfAuditMutation) SetToolVersion(s string) {
	m.tool_version = &s
}

// ToolVersion returns the value of the "tool_version" field in the mutation.
func (m *SelfAuditMutation) ToolVersion() (r string, exists bool) {
	v := m.tool_version
	if v == nil {
		return
	}
	return *v, true
}

// OldToolVersion returns the old "tool_version" field's value of the SelfAudit entity.
// If the SelfAudit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SelfAuditMutation) OldToolVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToolVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToolVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolVersion: %w", err)
	}
	return oldValue.ToolVersion, nil
}

// ResetToolVersion resets all changes to the "tool_version" field.
func (m *SelfAuditMutation) ResetToolVersion() {
	m.tool_version = nil
}

// Where appends a list predicates to the SelfAuditMutation builder.
func (m *SelfAuditMutation) Where(ps ...predicate.SelfAudit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SelfAuditMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SelfAuditMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SelfAudit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SelfAuditMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SelfAuditMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SelfAudit).
func (m *SelfAuditMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SelfAuditMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.timestamp != nil {
		fields = append(fields, selfaudit.FieldTimestamp)
	}
	if m.action != nil {
		fields = append(fields, selfaudit.FieldAction)
	}
	if m.agent_name != nil {
		fields = append(fields, selfaudit.FieldAgentName)
	}
	if m.details != nil {
		fields = append(fields, selfaudit.FieldDetails)
	}
	if m.result != nil {
		fields = append(fields, selfaudit.FieldResult)
	}
	if m.error_message != nil {
		fields = append(fields, selfaudit.FieldErrorMessage)
	}
	if m.tool_version != nil {
		fields = append(fields, selfaudit.FieldToolVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SelfAuditMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case selfaudit.FieldTimestamp:
		return m.Timestamp()
	case selfaudit.FieldAction:
		return m.Action()
	case selfaudit.FieldAgentName:
		return m.AgentName()
	case selfaudit.FieldDetails:
		return m.Details()
	case selfaudit.FieldResult:
		return m.Result()
	case selfaudit.FieldErrorMessage:
		return m.ErrorMessage()
	case selfaudit.FieldToolVersion:
		return m.ToolVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SelfAuditMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case selfaudit.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case selfaudit.FieldAction:
		return m.OldAction(ctx)
	case selfaudit.FieldAgentName:
		return m.OldAgentName(ctx)
	case selfaudit.FieldDetails:
		return m.OldDetails(ctx)
	case selfaudit.FieldResult:
		return m.OldResult(ctx)
	case selfaudit.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case selfaudit.FieldToolVersion:
		return m.OldToolVersion(ctx)
	}
	return nil, fmt.Errorf("unknown SelfAudit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SelfAuditMutation) SetField(name string, value ent.Value) error {
	switch name {
	case selfaudit.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case selfaudit.FieldAction:
		v, ok := value.(selfaudit.Action)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case selfaudit.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case selfaudit.FieldDetails:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetails(v)
		return nil
	case selfaudit.FieldResult:
		v, ok := value.(selfaudit.Result)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case selfaudit.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case selfaudit.FieldToolVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolVersion(v)
		return nil
	}
	return fmt.Errorf("unknown SelfAudit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SelfAuditMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SelfAuditMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SelfAuditMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SelfAudit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SelfAuditMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(selfaudit.FieldAgentName) {
		fields = append(fields, selfaudit.FieldAgentName)
	}
	if m.FieldCleared(selfaudit.FieldDetails) {
		fields = append(fields, selfaudit.FieldDetails)
	}
	if m.FieldCleared(selfaudit.FieldErrorMessage) {
		fields = append(fields, selfaudit.FieldErrorMessage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SelfAuditMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SelfAuditMutation) ClearField(name string) error {
	switch name {
	case selfaudit.FieldAgentName:
		m.ClearAgentName()
		return nil
	case selfaudit.FieldDetails:
		m.ClearDetails()
		return nil
	case selfaudit.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	}
	return fmt.Errorf("unknown SelfAudit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SelfAuditMutation) ResetField(name string) error {
	switch name {
	case selfaudit.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case selfaudit.FieldAction:
		m.ResetAction()
		return nil
	case selfaudit.FieldAgentName:
		m.ResetAgentName()
		return nil
	case selfaudit.FieldDetails:
		m.ResetDetails()
		return nil
	case selfaudit.FieldResult:
		m.ResetResult()
		return nil
	case selfaudit.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case selfaudit.FieldToolVersion:
		m.ResetToolVersion()
		return nil
	}
	return fmt.Errorf("unknown SelfAudit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SelfAuditMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SelfAuditMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SelfAuditMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SelfAuditMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SelfAuditMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SelfAuditMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SelfAuditMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SelfAudit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SelfAuditMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SelfAudit edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	agent_session_id     *string
	agent_name           *string
	agent_version        *string
	started_at           *time.Time
	ended_at             *time.Time
	working_directory    *string
	project_name         *string
	total_actions        *int
	addtotal_actions     *int
	files_read           *int
	addfiles_read        *int
	files_written        *int
	addfiles_written     *int
	commands_executed    *int
	addcommands_executed *int
	errors               *int
	adderrors            *int
	clearedFields        map[string]struct{}
	events               map[uuid.UUID]struct{}
	removedevents        map[uuid.UUID]struct{}
	clearedevents        bool
	done                 bool
	oldValue             func(context.Context) (*Session, error)
	predicates           []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgentSessionID sets the "agent_session_id" field.
func (m *SessionMutation) SetAgentSessionID(s string) {
	m.agent_session_id = &s
}

// AgentSessionID returns the value of the "agent_session_id" field in the mutation.
func (m *SessionMutation) AgentSessionID() (r string, exists bool) {
	v := m.agent_session_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentSessionID returns the old "agent_session_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAgentSessionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentSessionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentSessionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentSessionID: %w", err)
	}
	return oldValue.AgentSessionID, nil
}

// ClearAgentSessionID clears the value of the "agent_session_id" field.
func (m *SessionMutation) ClearAgentSessionID() {
	m.agent_session_id = nil
	m.clearedFields[session.FieldAgentSessionID] = struct{}{}
}

// AgentSessionIDCleared returns if the "agent_session_id" field was cleared in this mutation.
func (m *SessionMutation) AgentSessionIDCleared() bool {
	_, ok := m.clearedFields[session.FieldAgentSessionID]
	return ok
}

// ResetAgentSessionID resets all changes to the "agent_session_id" field.
func (m *SessionMutation) ResetAgentSessionID() {
	m.agent_session_id = nil
	delete(m.clearedFields, session.FieldAgentSessionID)
}

// SetAgentName sets the "agent_name" field.
func (m *SessionMutation) SetAgentName(s string) {
	m.agent_name = &s
}

// AgentName returns the value of the "agent_name" field in the mutation.
func (m *SessionMutation) AgentName() (r string, exists bool) {
	v := m.agent_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentName returns the old "agent_name" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAgentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentName: %w", err)
	}
	return oldValue.AgentName, nil
}

// ResetAgentName resets all changes to the "agent_name" field.
func (m *SessionMutation) ResetAgentName() {
	m.agent_name = nil
}

// SetAgentVersion sets the "agent_version" field.
func (m *SessionMutation) SetAgentVersion(s string) {
	m.agent_version = &s
}

// AgentVersion returns the value of the "agent_version" field in the mutation.
func (m *SessionMutation) AgentVersion() (r string, exists bool) {
	v := m.agent_version
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentVersion returns the old "agent_version" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAgentVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentVersion: %w", err)
	}
	return oldValue.AgentVersion, nil
}

// ClearAgentVersion clears the value of the "agent_version" field.
func (m *SessionMutation) ClearAgentVersion() {
	m.agent_version = nil
	m.clearedFields[session.FieldAgentVersion] = struct{}{}
}

// AgentVersionCleared returns if the "agent_version" field was cleared in this mutation.
func (m *SessionMutation) AgentVersionCleared() bool {
	_, ok := m.clearedFields[session.FieldAgentVersion]
	return ok
}

// ResetAgentVersion resets all changes to the "agent_version" field.
func (m *SessionMutation) ResetAgentVersion() {
	m.agent_version = nil
	delete(m.clearedFields, session.FieldAgentVersion)
}

// SetStartedAt sets the "started_at" field.
func (m *SessionMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *SessionMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *SessionMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetEndedAt sets the "ended_at" field.
func (m *SessionMutation) SetEndedAt(t time.Time) {
	m.ended_at = &t
}

// EndedAt returns the value of the "ended_at" field in the mutation.
func (m *SessionMutation) EndedAt() (r time.Time, exists bool) {
	v := m.ended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndedAt returns the old "ended_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldEndedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndedAt: %w", err)
	}
	return oldValue.EndedAt, nil
}

// ClearEndedAt clears the value of the "ended_at" field.
func (m *SessionMutation) ClearEndedAt() {
	m.ended_at = nil
	m.clearedFields[session.FieldEndedAt] = struct{}{}
}

// EndedAtCleared returns if the "ended_at" field was cleared in this mutation.
func (m *SessionMutation) EndedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldEndedAt]
	return ok
}

// ResetEndedAt resets all changes to the "ended_at" field.
func (m *SessionMutation) ResetEndedAt() {
	m.ended_at = nil
	delete(m.clearedFields, session.FieldEndedAt)
}

// SetWorkingDirectory sets the "working_directory" field.
func (m *SessionMutation) SetWorkingDirectory(s string) {
	m.working_directory = &s
}

// WorkingDirectory returns the value of the "working_directory" field in the mutation.
func (m *SessionMutation) WorkingDirectory() (r string, exists bool) {
	v := m.working_directory
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkingDirectory returns the old "working_directory" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldWorkingDirectory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkingDirectory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkingDirectory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkingDirectory: %w", err)
	}
	return oldValue.WorkingDirectory, nil
}

// ClearWorkingDirectory clears the value of the "working_directory" field.
func (m *SessionMutation) ClearWorkingDirectory() {
	m.working_directory = nil
	m.clearedFields[session.FieldWorkingDirectory] = struct{}{}
}

// WorkingDirectoryCleared returns if the "working_directory" field was cleared in this mutation.
func (m *SessionMutation) WorkingDirectoryCleared() bool {
	_, ok := m.clearedFields[session.FieldWorkingDirectory]
	return ok
}

// ResetWorkingDirectory resets all changes to the "working_directory" field.
func (m *SessionMutation) ResetWorkingDirectory() {
	m.working_directory = nil
	delete(m.clearedFields, session.FieldWorkingDirectory)
}

// SetProjectName sets the "project_name" field.
func (m *SessionMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *SessionMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ClearProjectName clears the value of the "project_name" field.
func (m *SessionMutation) ClearProjectName() {
	m.project_name = nil
	m.clearedFields[session.FieldProjectName] = struct{}{}
}

// ProjectNameCleared returns if the "project_name" field was cleared in this mutation.
func (m *SessionMutation) ProjectNameCleared() bool {
	_, ok := m.clearedFields[session.FieldProjectName]
	return ok
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *SessionMutation) ResetProjectName() {
	m.project_name = nil
	delete(m.clearedFields, session.FieldProjectName)
}

// SetTotalActions sets the "total_actions" field.
func (m *SessionMutation) SetTotalActions(i int) {
	m.total_actions = &i
	m.addtotal_actions = nil
}

// TotalActions returns the value of the "total_actions" field in the mutation.
func (m *SessionMutation) TotalActions() (r int, exists bool) {
	v := m.total_actions
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalActions returns the old "total_actions" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldTotalActions(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalActions: %w", err)
	}
	return oldValue.TotalActions, nil
}

// AddTotalActions adds i to the "total_actions" field.
func (m *SessionMutation) AddTotalActions(i int) {
	if m.addtotal_actions != nil {
		*m.addtotal_actions += i
	} else {
		m.addtotal_actions = &i
	}
}

// AddedTotalActions returns the value that was added to the "total_actions" field in this mutation.
func (m *SessionMutation) AddedTotalActions() (r int, exists bool) {
	v := m.addtotal_actions
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalActions resets all changes to the "total_actions" field.
func (m *SessionMutation) ResetTotalActions() {
	m.total_actions = nil
	m.addtotal_actions = nil
}

// SetFilesRead sets the "files_read" field.
func (m *SessionMutation) SetFilesRead(i int) {
	m.files_read = &i
	m.addfiles_read = nil
}

// FilesRead returns the value of the "files_read" field in the mutation.
func (m *SessionMutation) FilesRead() (r int, exists bool) {
	v := m.files_read
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesRead returns the old "files_read" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldFilesRead(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesRead: %w", err)
	}
	return oldValue.FilesRead, nil
}

// AddFilesRead adds i to the "files_read" field.
func (m *SessionMutation) AddFilesRead(i int) {
	if m.addfiles_read != nil {
		*m.addfiles_read += i
	} else {
		m.addfiles_read = &i
	}
}

// AddedFilesRead returns the value that was added to the "files_read" field in this mutation.
func (m *SessionMutation) AddedFilesRead() (r int, exists bool) {
	v := m.addfiles_read
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesRead resets all changes to the "files_read" field.
func (m *SessionMutation) ResetFilesRead() {
	m.files_read = nil
	m.addfiles_read = nil
}

// SetFilesWritten sets the "files_written" field.
func (m *SessionMutation) SetFilesWritten(i int) {
	m.files_written = &i
	m.addfiles_written = nil
}

// FilesWritten returns the value of the "files_written" field in the mutation.
func (m *SessionMutation) FilesWritten() (r int, exists bool) {
	v := m.files_written
	if v == nil {
		return
	}
	return *v, true
}

// OldFilesWritten returns the old "files_written" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldFilesWritten(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilesWritten is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilesWritten requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilesWritten: %w", err)
	}
	return oldValue.FilesWritten, nil
}

// AddFilesWritten adds i to the "files_written" field.
func (m *SessionMutation) AddFilesWritten(i int) {
	if m.addfiles_written != nil {
		*m.addfiles_written += i
	} else {
		m.addfiles_written = &i
	}
}

// AddedFilesWritten returns the value that was added to the "files_written" field in this mutation.
func (m *SessionMutation) AddedFilesWritten() (r int, exists bool) {
	v := m.addfiles_written
	if v == nil {
		return
	}
	return *v, true
}

// ResetFilesWritten resets all changes to the "files_written" field.
func (m *SessionMutation) ResetFilesWritten() {
	m.files_written = nil
	m.addfiles_written = nil
}

// SetCommandsExecuted sets the "commands_executed" field.
func (m *SessionMutation) SetCommandsExecuted(i int) {
	m.commands_executed = &i
	m.addcommands_executed = nil
}

// CommandsExecuted returns the value of the "commands_executed" field in the mutation.
func (m *SessionMutation) CommandsExecuted() (r int, exists bool) {
	v := m.commands_executed
	if v == nil {
		return
	}
	return *v, true
}

// OldCommandsExecuted returns the old "commands_executed" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCommandsExecuted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommandsExecuted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommandsExecuted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommandsExecuted: %w", err)
	}
	return oldValue.CommandsExecuted, nil
}

// AddCommandsExecuted adds i to the "commands_executed" field.
func (m *SessionMutation) AddCommandsExecuted(i int) {
	if m.addcommands_executed != nil {
		*m.addcommands_executed += i
	} else {
		m.addcommands_executed = &i
	}
}

// AddedCommandsExecuted returns the value that was added to the "commands_executed" field in this mutation.
func (m *SessionMutation) AddedCommandsExecuted() (r int, exists bool) {
	v := m.addcommands_executed
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommandsExecuted resets all changes to the "commands_executed" field.
func (m *SessionMutation) ResetCommandsExecuted() {
	m.commands_executed = nil
	m.addcommands_executed = nil
}

// SetErrors sets the "errors" field.
func (m *SessionMutation) SetErrors(i int) {
	m.errors = &i
	m.adderrors = nil
}

// Errors returns the value of the "errors" field in the mutation.
func (m *SessionMutation) Errors() (r int, exists bool) {
	v := m.errors
	if v == nil {
		return
	}
	return *v, true
}

// OldErrors returns the old "errors" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldErrors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrors: %w", err)
	}
	return oldValue.Errors, nil
}

// AddErrors adds i to the "errors" field.
func (m *SessionMutation) AddErrors(i int) {
	if m.adderrors != nil {
		*m.adderrors += i
	} else {
		m.adderrors = &i
	}
}

// AddedErrors returns the value that was added to the "errors" field in this mutation.
func (m *SessionMutation) AddedErrors() (r int, exists bool) {
	v := m.adderrors
	if v == nil {
		return
	}
	return *v, true
}

// ResetErrors resets all changes to the "errors" field.
func (m *SessionMutation) ResetErrors() {
	m.errors = nil
	m.adderrors = nil
}

// AddEventIDs adds the "events" edge to the AuditEvent entity by ids.
func (m *SessionMutation) AddEventIDs(ids ...uuid.UUID) {
	if m.events == nil {
		m.events = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the AuditEvent entity.
func (m *SessionMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the AuditEvent entity was cleared.
func (m *SessionMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the AuditEvent entity by IDs.
func (m *SessionMutation) RemoveEventIDs(ids ...uuid.UUID) {
	if m.removedevents == nil {
		m.removedevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the AuditEvent entity.
func (m *SessionMutation) RemovedEventsIDs() (ids []uuid.UUID) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *SessionMutation) EventsIDs() (ids []uuid.UUID) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *SessionMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.agent_session_id != nil {
		fields = append(fields, session.FieldAgentSessionID)
	}
	if m.agent_name != nil {
		fields = append(fields, session.FieldAgentName)
	}
	if m.agent_version != nil {
		fields = append(fields, session.FieldAgentVersion)
	}
	if m.started_at != nil {
		fields = append(fields, session.FieldStartedAt)
	}
	if m.ended_at != nil {
		fields = append(fields, session.FieldEndedAt)
	}
	if m.working_directory != nil {
		fields = append(fields, session.FieldWorkingDirectory)
	}
	if m.project_name != nil {
		fields = append(fields, session.FieldProjectName)
	}
	if m.total_actions != nil {
		fields = append(fields, session.FieldTotalActions)
	}
	if m.files_read != nil {
		fields = append(fields, session.FieldFilesRead)
	}
	if m.files_written != nil {
		fields = append(fields, session.FieldFilesWritten)
	}
	if m.commands_executed != nil {
		fields = append(fields, session.FieldCommandsExecuted)
	}
	if m.errors != nil {
		fields = append(fields, session.FieldErrors)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldAgentSessionID:
		return m.AgentSessionID()
	case session.FieldAgentName:
		return m.AgentName()
	case session.FieldAgentVersion:
		return m.AgentVersion()
	case session.FieldStartedAt:
		return m.StartedAt()
	case session.FieldEndedAt:
		return m.EndedAt()
	case session.FieldWorkingDirectory:
		return m.WorkingDirectory()
	case session.FieldProjectName:
		return m.ProjectName()
	case session.FieldTotalActions:
		return m.TotalActions()
	case session.FieldFilesRead:
		return m.FilesRead()
	case session.FieldFilesWritten:
		return m.FilesWritten()
	case session.FieldCommandsExecuted:
		return m.CommandsExecuted()
	case session.FieldErrors:
		return m.Errors()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldAgentSessionID:
		return m.OldAgentSessionID(ctx)
	case session.FieldAgentName:
		return m.OldAgentName(ctx)
	case session.FieldAgentVersion:
		return m.OldAgentVersion(ctx)
	case session.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case session.FieldEndedAt:
		return m.OldEndedAt(ctx)
	case session.FieldWorkingDirectory:
		return m.OldWorkingDirectory(ctx)
	case session.FieldProjectName:
		return m.OldProjectName(ctx)
	case session.FieldTotalActions:
		return m.OldTotalActions(ctx)
	case session.FieldFilesRead:
		return m.OldFilesRead(ctx)
	case session.FieldFilesWritten:
		return m.OldFilesWritten(ctx)
	case session.FieldCommandsExecuted:
		return m.OldCommandsExecuted(ctx)
	case session.FieldErrors:
		return m.OldErrors(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldAgentSessionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentSessionID(v)
		return nil
	case session.FieldAgentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentName(v)
		return nil
	case session.FieldAgentVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentVersion(v)
		return nil
	case session.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case session.FieldEndedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndedAt(v)
		return nil
	case session.FieldWorkingDirectory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkingDirectory(v)
		return nil
	case session.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case session.FieldTotalActions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalActions(v)
		return nil
	case session.FieldFilesRead:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesRead(v)
		return nil
	case session.FieldFilesWritten:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilesWritten(v)
		return nil
	case session.FieldCommandsExecuted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommandsExecuted(v)
		return nil
	case session.FieldErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrors(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_actions != nil {
		fields = append(fields, session.FieldTotalActions)
	}
	if m.addfiles_read != nil {
		fields = append(fields, session.FieldFilesRead)
	}
	if m.addfiles_written != nil {
		fields = append(fields, session.FieldFilesWritten)
	}
	if m.addcommands_executed != nil {
		fields = append(fields, session.FieldCommandsExecuted)
	}
	if m.adderrors != nil {
		fields = append(fields, session.FieldErrors)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldTotalActions:
		return m.AddedTotalActions()
	case session.FieldFilesRead:
		return m.AddedFilesRead()
	case session.FieldFilesWritten:
		return m.AddedFilesWritten()
	case session.FieldCommandsExecuted:
		return m.AddedCommandsExecuted()
	case session.FieldErrors:
		return m.AddedErrors()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldTotalActions:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalActions(v)
		return nil
	case session.FieldFilesRead:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesRead(v)
		return nil
	case session.FieldFilesWritten:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFilesWritten(v)
		return nil
	case session.FieldCommandsExecuted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommandsExecuted(v)
		return nil
	case session.FieldErrors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddErrors(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldAgentSessionID) {
		fields = append(fields, session.FieldAgentSessionID)
	}
	if m.FieldCleared(session.FieldAgentVersion) {
		fields = append(fields, session.FieldAgentVersion)
	}
	if m.FieldCleared(session.FieldEndedAt) {
		fields = append(fields, session.FieldEndedAt)
	}
	if m.FieldCleared(session.FieldWorkingDirectory) {
		fields = append(fields, session.FieldWorkingDirectory)
	}
	if m.FieldCleared(session.FieldProjectName) {
		fields = append(fields, session.FieldProjectName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldAgentSessionID:
		m.ClearAgentSessionID()
		return nil
	case session.FieldAgentVersion:
		m.ClearAgentVersion()
		return nil
	case session.FieldEndedAt:
		m.ClearEndedAt()
		return nil
	case session.FieldWorkingDirectory:
		m.ClearWorkingDirectory()
		return nil
	case session.FieldProjectName:
		m.ClearProjectName()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldAgentSessionID:
		m.ResetAgentSessionID()
		return nil
	case session.FieldAgentName:
		m.ResetAgentName()
		return nil
	case session.FieldAgentVersion:
		m.ResetAgentVersion()
		return nil
	case session.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case session.FieldEndedAt:
		m.ResetEndedAt()
		return nil
	case session.FieldWorkingDirectory:
		m.ResetWorkingDirectory()
		return nil
	case session.FieldProjectName:
		m.ResetProjectName()
		return nil
	case session.FieldTotalActions:
		m.ResetTotalActions()
		return nil
	case session.FieldFilesRead:
		m.ResetFilesRead()
		return nil
	case session.FieldFilesWritten:
		m.ResetFilesWritten()
		return nil
	case session.FieldCommandsExecuted:
		m.ResetCommandsExecuted()
		return nil
	case session.FieldErrors:
		m.ResetErrors()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, session.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, session.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, session.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// StreamCheckpointMutation represents an operation that mutates the StreamCheckpoint nodes in the graph.
type StreamCheckpointMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	last_synced_at     *time.Time
	last_event_id      *string
	last_self_audit_id *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*StreamCheckpoint, error)
	predicates         []predicate.StreamCheckpoint
}

var _ ent.Mutation = (*StreamCheckpointMutation)(nil)

// streamcheckpointOption allows management of the mutation configuration using functional options.
type streamcheckpointOption func(*StreamCheckpointMutation)

// newStreamCheckpointMutation creates new mutation for the StreamCheckpoint entity.
func newStreamCheckpointMutation(c config, op Op, opts ...streamcheckpointOption) *StreamCheckpointMutation {
	m := &StreamCheckpointMutation{
		config:        c,
		op:            op,
		typ:           TypeStreamCheckpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStreamCheckpointID sets the ID field of the mutation.
func withStreamCheckpointID(id string) streamcheckpointOption {
	return func(m *StreamCheckpointMutation) {
		var (
			err   error
			once  sync.Once
			value *StreamCheckpoint
		)
		m.oldValue = func(ctx context.Context) (*StreamCheckpoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StreamCheckpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStreamCheckpoint sets the old StreamCheckpoint of the mutation.
func withStreamCheckpoint(node *StreamCheckpoint) streamcheckpointOption {
	return func(m *StreamCheckpointMutation) {
		m.oldValue = func(context.Context) (*StreamCheckpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StreamCheckpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StreamCheckpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StreamCheckpoint entities.
func (m *StreamCheckpointMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StreamCheckpointMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StreamCheckpointMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StreamCheckpoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLastSyncedAt sets the "last_synced_at" field.
func (m *StreamCheckpointMutation) SetLastSyncedAt(t time.Time) {
	m.last_synced_at = &t
}

// LastSyncedAt returns the value of the "last_synced_at" field in the mutation.
func (m *StreamCheckpointMutation) LastSyncedAt() (r time.Time, exists bool) {
	v := m.last_synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSyncedAt returns the old "last_synced_at" field's value of the StreamCheckpoint entity.
// If the StreamCheckpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamCheckpointMutation) OldLastSyncedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSyncedAt: %w", err)
	}
	return oldValue.LastSyncedAt, nil
}

// ResetLastSyncedAt resets all changes to the "last_synced_at" field.
func (m *StreamCheckpointMutation) ResetLastSyncedAt() {
	m.last_synced_at = nil
}

// SetLastEventID sets the "last_event_id" field.
func (m *StreamCheckpointMutation) SetLastEventID(s string) {
	m.last_event_id = &s
}

// LastEventID returns the value of the "last_event_id" field in the mutation.
func (m *StreamCheckpointMutation) LastEventID() (r string, exists bool) {
	v := m.last_event_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastEventID returns the old "last_event_id" field's value of the StreamCheckpoint entity.
// If the StreamCheckpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamCheckpointMutation) OldLastEventID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastEventID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastEventID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastEventID: %w", err)
	}
	return oldValue.LastEventID, nil
}

// ClearLastEventID clears the value of the "last_event_id" field.
func (m *StreamCheckpointMutation) ClearLastEventID() {
	m.last_event_id = nil
	m.clearedFields[streamcheckpoint.FieldLastEventID] = struct{}{}
}

// LastEventIDCleared returns if the "last_event_id" field was cleared in this mutation.
func (m *StreamCheckpointMutation) LastEventIDCleared() bool {
	_, ok := m.clearedFields[streamcheckpoint.FieldLastEventID]
	return ok
}

// ResetLastEventID resets all changes to the "last_event_id" field.
func (m *StreamCheckpointMutation) ResetLastEventID() {
	m.last_event_id = nil
	delete(m.clearedFields, streamcheckpoint.FieldLastEventID)
}

// SetLastSelfAuditID sets the "last_self_audit_id" field.
func (m *StreamCheckpointMutation) SetLastSelfAuditID(s string) {
	m.last_self_audit_id = &s
}

// LastSelfAuditID returns the value of the "last_self_audit_id" field in the mutation.
func (m *StreamCheckpointMutation) LastSelfAuditID() (r string, exists bool) {
	v := m.last_self_audit_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSelfAuditID returns the old "last_self_audit_id" field's value of the StreamCheckpoint entity.
// If the StreamCheckpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamCheckpointMutation) OldLastSelfAuditID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSelfAuditID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSelfAuditID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSelfAuditID: %w", err)
	}
	return oldValue.LastSelfAuditID, nil
}

// ClearLastSelfAuditID clears the value of the "last_self_audit_id" field.
func (m *StreamCheckpointMutation) ClearLastSelfAuditID() {
	m.last_self_audit_id = nil
	m.clearedFields[streamcheckpoint.FieldLastSelfAuditID] = struct{}{}
}

// LastSelfAuditIDCleared returns if the "last_self_audit_id" field was cleared in this mutation.
func (m *StreamCheckpointMutation) LastSelfAuditIDCleared() bool {
	_, ok := m.clearedFields[streamcheckpoint.FieldLastSelfAuditID]
	return ok
}

// ResetLastSelfAuditID resets all changes to the "last_self_audit_id" field.
func (m *StreamCheckpointMutation) ResetLastSelfAuditID() {
	m.last_self_audit_id = nil
	delete(m.clearedFields, streamcheckpoint.FieldLastSelfAuditID)
}

// Where appends a list predicates to the StreamCheckpointMutation builder.
func (m *StreamCheckpointMutation) Where(ps ...predicate.StreamCheckpoint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StreamCheckpointMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StreamCheckpointMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StreamCheckpoint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StreamCheckpointMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StreamCheckpointMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StreamCheckpoint).
func (m *StreamCheckpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StreamCheckpointMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.last_synced_at != nil {
		fields = append(fields, streamcheckpoint.FieldLastSyncedAt)
	}
	if m.last_event_id != nil {
		fields = append(fields, streamcheckpoint.FieldLastEventID)
	}
	if m.last_self_audit_id != nil {
		fields = append(fields, streamcheckpoint.FieldLastSelfAuditID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StreamCheckpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case streamcheckpoint.FieldLastSyncedAt:
		return m.LastSyncedAt()
	case streamcheckpoint.FieldLastEventID:
		return m.LastEventID()
	case streamcheckpoint.FieldLastSelfAuditID:
		return m.LastSelfAuditID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StreamCheckpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case streamcheckpoint.FieldLastSyncedAt:
		return m.OldLastSyncedAt(ctx)
	case streamcheckpoint.FieldLastEventID:
		return m.OldLastEventID(ctx)
	case streamcheckpoint.FieldLastSelfAuditID:
		return m.OldLastSelfAuditID(ctx)
	}
	return nil, fmt.Errorf("unknown StreamCheckpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreamCheckpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case streamcheckpoint.FieldLastSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSyncedAt(v)
		return nil
	case streamcheckpoint.FieldLastEventID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastEventID(v)
		return nil
	case streamcheckpoint.FieldLastSelfAuditID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSelfAuditID(v)
		return nil
	}
	return fmt.Errorf("unknown StreamCheckpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StreamCheckpointMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StreamCheckpointMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreamCheckpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StreamCheckpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StreamCheckpointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(streamcheckpoint.FieldLastEventID) {
		fields = append(fields, streamcheckpoint.FieldLastEventID)
	}
	if m.FieldCleared(streamcheckpoint.FieldLastSelfAuditID) {
		fields = append(fields, streamcheckpoint.FieldLastSelfAuditID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StreamCheckpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StreamCheckpointMutation) ClearField(name string) error {
	switch name {
	case streamcheckpoint.FieldLastEventID:
		m.ClearLastEventID()
		return nil
	case streamcheckpoint.FieldLastSelfAuditID:
		m.ClearLastSelfAuditID()
		return nil
	}
	return fmt.Errorf("unknown StreamCheckpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StreamCheckpointMutation) ResetField(name string) error {
	switch name {
	case streamcheckpoint.FieldLastSyncedAt:
		m.ResetLastSyncedAt()
		return nil
	case streamcheckpoint.FieldLastEventID:
		m.ResetLastEventID()
		return nil
	case streamcheckpoint.FieldLastSelfAuditID:
		m.ResetLastSelfAuditID()
		return nil
	}
	return fmt.Errorf("unknown StreamCheckpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StreamCheckpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StreamCheckpointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StreamCheckpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StreamCheckpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StreamCheckpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StreamCheckpointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StreamCheckpointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StreamCheckpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StreamCheckpointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StreamCheckpoint edge %s", name)
}
